
  // ============= CHAT ROUTES =============

  // Create chat conversation
  app.post("/api/chat/conversation", async (req, res) => {
    try {
      const data = insertChatConversationSchema.parse(req.body);
      const conversation = await storage.createChatConversation(data);
      res.json(conversation);
    } catch (error) {
      console.error("Error creating conversation:", error);
      res.status(400).json({
        error: "Failed to create conversation",
      });
    }
  });

  // Get conversation by session
  app.get("/api/chat/conversation/session/:sessionId", async (req, res) => {
    try {
      const conversations = await storage.getChatConversationsBySession(
        req.params.sessionId,
      );
      res.json(conversations);
    } catch (error) {
      console.error("Error fetching conversations:", error);
      res.status(500).json({
        error: "Failed to fetch conversations",
      });
    }
  });

  // Get messages for conversation
  app.get("/api/chat/conversation/:id/messages", async (req, res) => {
    try {
      const messages = await storage.getChatMessagesByConversation(
        req.params.id,
      );
      res.json(messages);
    } catch (error) {
      console.error("Error fetching messages:", error);
      res.status(500).json({
        error: "Failed to fetch messages",
      });
    }
  });

  // Send chat message (with AI response)
  app.post("/api/chat/message", async (req, res) => {
    try {
      const { conversationId, content, sessionId } = req.body;

      // Get or create conversation
      let conversation;
      if (conversationId) {
        conversation = await storage.getChatConversation(conversationId);
      } else if (sessionId) {
        // Create new conversation for this session
        conversation = await storage.createChatConversation({
          sessionId,
          isActive: true,
        });
      }

      if (!conversation) {
        return res.status(404).json({ error: "Conversation not found" });
      }

      // Save user message
      const userMessage = await storage.createChatMessage({
        conversationId: conversation.id,
        role: "user",
        content,
      });

      // Get conversation history
      const messages = await storage.getChatMessagesByConversation(
        conversation.id,
      );

      // Generate AI response
      const { generateChatResponse, SYSTEM_PROMPT } = await import(
        "./utils/openai"
      );

      const chatHistory = [
        { role: "system" as const, content: SYSTEM_PROMPT },
        ...messages.map((msg) => ({
          role: msg.role as "user" | "assistant",
          content: msg.content,
        })),
      ];

      const aiResponse = await generateChatResponse(chatHistory);

      // Save AI message
      const assistantMessage = await storage.createChatMessage({
        conversationId: conversation.id,
        role: "assistant",
        content: aiResponse,
      });

      // Update conversation title if first message
      if (messages.length === 1) {
        await storage.updateChatConversation(conversation.id, {
          title: content.slice(0, 50) + (content.length > 50 ? "..." : ""),
        });
      }

      res.json({
        userMessage,
        assistantMessage,
        conversationId: conversation.id,
      });
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(400).json({
        error:
          error instanceof Error ? error.message : "Failed to send message",
      });
    }
  });